// Конфигурация API
const API_CONFIG = {
    weather: {
        key: '6a7d745ce2e234ddf96233e012ff642a', // Замените на ваш ключ
        url: 'https://api.openweathermap.org/data/2.5/weather'
    },
    currency: {
        url: 'https://api.exchangerate-api.com/v4/latest/RUB'
    },
    quotes: {
        url: 'https://api.quotable.io/random'
    }
};

// Доступные виджеты
const AVAILABLE_WIDGETS = {
    weather: {
        name: 'Погода',
        type: 'weather',
        defaultSettings: { city: 'Москва', units: 'metric' }
    },
    currency: {
        name: 'Курсы валют',
        type: 'currency',
        defaultSettings: { currencies: ['USD', 'EUR'] }
    },
    quote: {
        name: 'Случайная цитата',
        type: 'quote',
        defaultSettings: {}
    },
    timer: {
        name: 'Таймер Pomodoro',
        type: 'timer',
        defaultSettings: { work: 25, break: 5 }
    },
    notes: {
        name: 'Заметки',
        type: 'notes',
        defaultSettings: {}
    }
};

class Dashboard {
    constructor() {
        this.widgets = [];
        this.draggedWidget = null;
        this.init();
    }

    init() {
        this.loadFromStorage();
        this.render();
        this.bindEvents();
    }

    bindEvents() {
        // Кнопки управления
        document.getElementById('addWidgetBtn').addEventListener('click', () => this.showWidgetModal());
        document.getElementById('closeModal').addEventListener('click', () => this.hideWidgetModal());
        document.getElementById('exportBtn').addEventListener('click', () => this.exportConfig());
        document.getElementById('importBtn').addEventListener('click', () => document.getElementById('importFile').click());
        document.getElementById('importFile').addEventListener('change', (e) => this.importConfig(e));

        // Drag & Drop
        document.addEventListener('dragstart', (e) => this.handleDragStart(e));
        document.addEventListener('dragover', (e) => this.handleDragOver(e));
        document.addEventListener('drop', (e) => this.handleDrop(e));
        document.addEventListener('dragend', (e) => this.handleDragEnd(e));
    }

    // Modal Management
    showWidgetModal() {
        const modal = document.getElementById('widgetModal');
        const widgetList = document.getElementById('widgetList');
        
        widgetList.innerHTML = Object.values(AVAILABLE_WIDGETS)
            .map(widget => `
                <div class="widget-option" data-type="${widget.type}">
                    <h3>${widget.name}</h3>
                    <p>Добавить виджет ${widget.name.toLowerCase()}</p>
                </div>
            `).join('');

        // Добавляем обработчики для выбора виджета
        widgetList.querySelectorAll('.widget-option').forEach(option => {
            option.addEventListener('click', (e) => {
                const type = e.currentTarget.dataset.type;
                this.addWidget(type);
                this.hideWidgetModal();
            });
        });

        modal.style.display = 'block';
    }

    hideWidgetModal() {
        document.getElementById('widgetModal').style.display = 'none';
    }

    // Widget Management
    addWidget(type, settings = null) {
        const widgetConfig = AVAILABLE_WIDGETS[type];
        if (!widgetConfig) return;

        const widget = {
            id: Date.now().toString(),
            type: type,
            name: widgetConfig.name,
            settings: settings || { ...widgetConfig.defaultSettings },
            data: null
        };

        this.widgets.push(widget);
        this.saveToStorage();
        this.render();
        this.loadWidgetData(widget.id);
    }

    removeWidget(id) {
        this.widgets = this.widgets.filter(widget => widget.id !== id);
        this.saveToStorage();
        this.render();
    }

    updateWidgetSettings(id, newSettings) {
        const widget = this.widgets.find(w => w.id === id);
        if (widget) {
            widget.settings = { ...widget.settings, ...newSettings };
            this.saveToStorage();
            this.loadWidgetData(id);
        }
    }

    // Data Loading
    async loadWidgetData(widgetId) {
        const widget = this.widgets.find(w => w.id === widgetId);
        if (!widget) return;

        const widgetElement = document.querySelector(`[data-widget-id="${widgetId}"]`);
        if (widgetElement) {
            this.showLoading(widgetElement);
        }

        try {
            let data;
            switch (widget.type) {
                case 'weather':
                    data = await this.fetchWeather(widget.settings.city);
                    break;
                case 'currency':
                    data = await this.fetchCurrencyRates();
                    break;
                case 'quote':
                    data = await this.fetchRandomQuote();
                    break;
                default:
                    data = null;
            }

            widget.data = data;
            this.saveToStorage();
            this.renderWidget(widget);
        } catch (error) {
            console.error('Error loading widget data:', error);
            this.showError(widgetElement, error.message);
        }
    }

    // API Methods
    async fetchWeather(city) {
        const response = await fetch(
            `${API_CONFIG.weather.url}?q=${city}&units=metric&appid=${API_CONFIG.weather.key}&lang=ru`
        );
        
        if (!response.ok) throw new Error('Не удалось загрузить данные о погоде');
        
        const data = await response.json();
        return {
            temp: Math.round(data.main.temp),
            description: data.weather[0].description,
            icon: data.weather[0].icon,
            city: data.name
        };
    }

    async fetchCurrencyRates() {
        const response = await fetch(API_CONFIG.currency.url);
        if (!response.ok) throw new Error('Не удалось загрузить курсы валют');
        
        const data = await response.json();
        return {
            rates: data.rates,
            date: data.date
        };
    }

    async fetchRandomQuote() {
        const response = await fetch(API_CONFIG.quotes.url);
        if (!response.ok) throw new Error('Не удалось загрузить цитату');
        
        return await response.json();
    }

    // Rendering
    render() {
        const dashboard = document.getElementById('dashboard');
        dashboard.innerHTML = this.widgets.map(widget => this.renderWidget(widget)).join('');
    }

    renderWidget(widget) {
        return `
            <div class="widget" data-widget-id="${widget.id}" draggable="true">
                <div class="widget-header">
                    <h3>${widget.name}</h3>
                    <div class="widget-controls">
                        <button class="refresh-btn" onclick="dashboard.loadWidgetData('${widget.id}')">↻</button>
                        <button class="settings-btn" onclick="dashboard.showSettings('${widget.id}')">⚙</button>
                        <button class="remove-btn" onclick="dashboard.removeWidget('${widget.id}')">×</button>
                    </div>
                </div>
                <div class="widget-content">
                    ${this.renderWidgetContent(widget)}
                </div>
            </div>
        `;
    }

    renderWidgetContent(widget) {
        if (!widget.data) {
            return this.renderLoading();
        }

        switch (widget.type) {
            case 'weather':
                return this.renderWeatherContent(widget);
            case 'currency':
                return this.renderCurrencyContent(widget);
            case 'quote':
                return this.renderQuoteContent(widget);
            case 'timer':
                return this.renderTimerContent(widget);
            case 'notes':
                return this.renderNotesContent(widget);
            default:
                return '<p>Виджет не поддерживается</p>';
        }
    }

    renderWeatherContent(widget) {
        const { temp, description, icon, city } = widget.data;
        return `
            <div style="text-align: center;">
                <h2>${temp}°C</h2>
                <p>${description}</p>
                <p>${city}</p>
                <img src="https://openweathermap.org/img/wn/${icon}.png" alt="${description}">
            </div>
        `;
    }

    renderCurrencyContent(widget) {
        const { rates, date } = widget.data;
        const selectedCurrencies = widget.settings.currencies || ['USD', 'EUR'];
        
        return `
            <div>
                <p><small>${new Date(date).toLocaleDateString()}</small></p>
                ${selectedCurrencies.map(currency => `
                    <div style="display: flex; justify-content: space-between; margin: 0.5rem 0;">
                        <span>${currency}/RUB</span>
                        <span>${(1 / rates[currency]).toFixed(2)}</span>
                    </div>
                `).join('')}
            </div>
        `;
    }

    renderQuoteContent(widget) {
        const { content, author } = widget.data;
        return `
            <div style="text-align: center;">
                <p>"${content}"</p>
                <p><strong>- ${author}</strong></p>
                <button onclick="dashboard.loadWidgetData('${widget.id}')" style="margin-top: 1rem;">
                    Следующая цитата
                </button>
            </div>
        `;
    }

    renderTimerContent(widget) {
        return `
            <div style="text-align: center;">
                <h2 id="timer-${widget.id}">25:00</h2>
                <div style="display: flex; gap: 0.5rem; justify-content: center; margin-top: 1rem;">
                    <button onclick="timerManager.startTimer('${widget.id}')">Старт</button>
                    <button onclick="timerManager.pauseTimer('${widget.id}')">Пауза</button>
                    <button onclick="timerManager.resetTimer('${widget.id}')">Сброс</button>
                </div>
                <div style="margin-top: 1rem;">
                    <label>Работа: </label>
                    <input type="number" id="work-${widget.id}" value="${widget.settings.work}" min="1" style="width: 50px;">
                    <label>Перерыв: </label>
                    <input type="number" id="break-${widget.id}" value="${widget.settings.break}" min="1" style="width: 50px;">
                </div>
            </div>
        `;
    }

    renderNotesContent(widget) {
        const notes = widget.data || [];
        return `
            <div>
                <textarea id="note-input-${widget.id}" placeholder="Новая заметка..." 
                         style="width: 100%; height: 60px; margin-bottom: 0.5rem;"></textarea>
                <button onclick="notesManager.addNote('${widget.id}')" style="width: 100%;">
                    Добавить заметку
                </button>
                <div id="notes-list-${widget.id}" style="margin-top: 1rem;">
                    ${notes.map((note, index) => `
                        <div style="display: flex; justify-content: space-between; align-items: center; 
                                   padding: 0.5rem; background: #f8f9fa; margin: 0.25rem 0; border-radius: 4px;">
                            <span>${note}</span>
                            <button onclick="notesManager.removeNote('${widget.id}', ${index})">×</button>
                        </div>
                    `).join('')}
                </div>
            </div>
        `;
    }

    renderLoading() {
        return `
            <div class="loading">
                <div class="spinner"></div>
            </div>
        `;
    }

    showLoading(widgetElement) {
        const content = widgetElement.querySelector('.widget-content');
        if (content) {
            content.innerHTML = this.renderLoading();
        }
    }

    showError(widgetElement, message) {
        const content = widgetElement.querySelector('.widget-content');
        if (content) {
            content.innerHTML = `
                <div class="error">
                    <p>${message}</p>
                    <button onclick="dashboard.loadWidgetData('${widgetElement.dataset.widgetId}')">
                        Повторить
                    </button>
                </div>
            `;
        }
    }

    // Settings Management
    showSettings(widgetId) {
        const widget = this.widgets.find(w => w.id === widgetId);
        if (!widget) return;

        let settingsHtml = '';
        switch (widget.type) {
            case 'weather':
                settingsHtml = `
                    <label>Город: </label>
                    <input type="text" id="weather-city" value="${widget.settings.city}">
                `;
                break;
            case 'currency':
                settingsHtml = `
                    <label>Валюты (через запятую): </label>
                    <input type="text" id="currency-list" value="${widget.settings.currencies.join(',')}">
                `;
                break;
        }

        if (settingsHtml) {
            const newSettings = prompt(`Настройки ${widget.name}:\n${settingsHtml}`);
            if (newSettings !== null) {
                this.handleSettingsInput(widgetId, widget.type);
            }
        }
    }

    handleSettingsInput(widgetId, type) {
        let newSettings = {};
        
        switch (type) {
            case 'weather':
                const city = document.getElementById('weather-city')?.value;
                if (city) newSettings = { city };
                break;
            case 'currency':
                const currenciesInput = document.getElementById('currency-list')?.value;
                if (currenciesInput) {
                    newSettings = { 
                        currencies: currenciesInput.split(',').map(c => c.trim().toUpperCase()) 
                    };
                }
                break;
        }

        if (Object.keys(newSettings).length > 0) {
            this.updateWidgetSettings(widgetId, newSettings);
        }
    }

    // Drag & Drop
    handleDragStart(e) {
        if (e.target.classList.contains('widget')) {
            this.draggedWidget = e.target;
            e.target.classList.add('dragging');
        }
    }

    handleDragOver(e) {
        e.preventDefault();
        const widget = e.target.closest('.widget');
        if (widget && widget !== this.draggedWidget) {
            widget.classList.add('drag-over');
        }
    }

    handleDrop(e) {
        e.preventDefault();
        const targetWidget = e.target.closest('.widget');
        
        if (this.draggedWidget && targetWidget && this.draggedWidget !== targetWidget) {
            const draggedId = this.draggedWidget.dataset.widgetId;
            const targetId = targetWidget.dataset.widgetId;
            
            this.reorderWidgets(draggedId, targetId);
        }
        
        this.clearDragStates();
    }

    handleDragEnd() {
        this.clearDragStates();
    }

    clearDragStates() {
        document.querySelectorAll('.widget').forEach(widget => {
            widget.classList.remove('dragging', 'drag-over');
        });
    }

    reorderWidgets(draggedId, targetId) {
        const draggedIndex = this.widgets.findIndex(w => w.id === draggedId);
        const targetIndex = this.widgets.findIndex(w => w.id === targetId);
        
        if (draggedIndex !== -1 && targetIndex !== -1) {
            const [draggedWidget] = this.widgets.splice(draggedIndex, 1);
            this.widgets.splice(targetIndex, 0, draggedWidget);
            this.saveToStorage();
            this.render();
        }
    }

    // Storage Management
    saveToStorage() {
        localStorage.setItem('dashboardConfig', JSON.stringify({
            widgets: this.widgets,
            version: '1.0'
        }));
    }

    loadFromStorage() {
        try {
            const saved = localStorage.getItem('dashboardConfig');
            if (saved) {
                const config = JSON.parse(saved);
                this.widgets = config.widgets || [];
                
                // Загружаем данные для всех виджетов
                this.widgets.forEach(widget => {
                    if (widget.type !== 'timer' && widget.type !== 'notes') {
                        this.loadWidgetData(widget.id);
                    }
                });
            }
        } catch (error) {
            console.error('Error loading from storage:', error);
            this.widgets = [];
        }
    }

    // Export/Import
    exportConfig() {
        const config = {
            widgets: this.widgets,
            exportDate: new Date().toISOString()
        };
        
        const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `dashboard-backup-${new Date().toISOString().split('T')[0]}.json`;
        a.click();
        URL.revokeObjectURL(url);
    }

    importConfig(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const config = JSON.parse(e.target.result);
                if (config.widgets) {
                    this.widgets = config.widgets;
                    this.saveToStorage();
                    this.render();
                    
                    // Перезагружаем данные
                    this.widgets.forEach(widget => {
                        if (widget.type !== 'timer' && widget.type !== 'notes') {
                            this.loadWidgetData(widget.id);
                        }
                    });
                    
                    alert('Конфигурация успешно импортирована!');
                }
            } catch (error) {
                alert('Ошибка при импорте конфигурации');
                console.error('Import error:', error);
            }
        };
        reader.readAsText(file);
        event.target.value = ''; // Сбрасываем input
    }
}

// Менеджер таймеров
class TimerManager {
    constructor() {
        this.timers = new Map();
    }

    startTimer(widgetId) {
        const widget = dashboard.widgets.find(w => w.id === widgetId);
        if (!widget) return;

        const workTime = parseInt(document.getElementById(`work-${widgetId}`).value) || 25;
        const breakTime = parseInt(document.getElementById(`break-${widgetId}`).value) || 5;

        // Обновляем настройки
        dashboard.updateWidgetSettings(widgetId, { work: workTime, break: breakTime });

        if (this.timers.has(widgetId)) {
            this.pauseTimer(widgetId);
        }

        this.timers.set(widgetId, {
            startTime: Date.now(),
            duration: workTime * 60 * 1000,
            isWork: true,
            isRunning: true
        });

        this.updateTimerDisplay(widgetId);
    }

    pauseTimer(widgetId) {
        const timer = this.timers.get(widgetId);
        if (timer) {
            timer.isRunning = false;
        }
    }

    resetTimer(widgetId) {
        this.timers.delete(widgetId);
        const widget = dashboard.widgets.find(w => w.id === widgetId);
        if (widget) {
            const display = document.getElementById(`timer-${widgetId}`);
            if (display) {
                display.textContent = `${widget.settings.work.toString().padStart(2, '0')}:00`;
            }
        }
    }

    updateTimerDisplay(widgetId) {
        const timer = this.timers.get(widgetId);
        if (!timer || !timer.isRunning) return;

        const elapsed = Date.now() - timer.startTime;
        const remaining = timer.duration - elapsed;

        if (remaining <= 0) {
            this.handleTimerComplete(widgetId, timer);
            return;
        }

        const minutes = Math.floor(remaining / 60000);
        const seconds = Math.floor((remaining % 60000) / 1000);

        const display = document.getElementById(`timer-${widgetId}`);
        if (display) {
            display.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        setTimeout(() => this.updateTimerDisplay(widgetId), 1000);
    }

    handleTimerComplete(widgetId, timer) {
        const widget = dashboard.widgets.find(w => w.id === widgetId);
        if (!widget) return;

        if (timer.isWork) {
            // Завершился рабочий период
            alert('Время работы завершено! Начинается перерыв.');
            this.timers.set(widgetId, {
                startTime: Date.now(),
                duration: widget.settings.break * 60 * 1000,
                isWork: false,
                isRunning: true
            });
        } else {
            // Завершился перерыв
            alert('Перерыв завершен!');
            this.timers.delete(widgetId);
            this.resetTimer(widgetId);
            return;
        }

        this.updateTimerDisplay(widgetId);
    }
}

// Менеджер заметок
class NotesManager {
    addNote(widgetId) {
        const widget = dashboard.widgets.find(w => w.id === widgetId);
        if (!widget) return;

        const input = document.getElementById(`note-input-${widgetId}`);
        const note = input.value.trim();

        if (note) {
            if (!widget.data) {
                widget.data = [];
            }
            widget.data.push(note);
            input.value = '';
            
            dashboard.saveToStorage();
            dashboard.renderWidget(widget);
        }
    }

    removeNote(widgetId, index) {
        const widget = dashboard.widgets.find(w => w.id === widgetId);
        if (widget && widget.data) {
            widget.data.splice(index, 1);
            dashboard.saveToStorage();
            dashboard.renderWidget(widget);
        }
    }
}

// Инициализация приложения
const dashboard = new Dashboard();
const timerManager = new TimerManager();
const notesManager = new NotesManager();